[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/Z6NE2ogx)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=16551255&assignment_repo_type=AssignmentRepo)
# Práctica 1: Introducción al desarrollo. Reflexiones.

Apoyate en los siguientes recursos para realizar la práctica:

[Descripción de la práctica](https://revilofe.github.io/section3/u01/practica/EDES-U1.-Practica010/)


---

# Título de la Actividad
Práctica 1: Introducción al desarrollo. Reflexiones.

## Identificación de la Actividad
- **ID de la Actividad:** [https://github.com/IES-Rafael-Alberti/2425-u1-1-1-reflexiones-Oscar-code21]
- **Módulo:** [EDES] (`PROG`, `IS`, `EDES`, etc.)
- **Unidad de Trabajo:** [Unidad 1 - Introducción al desarrollo software]
- **Fecha de Creación:** [Fecha de creación]
- **Fecha de Entrega:** [18/10/24]
- **Alumno(s):** 
  - **Nombre y Apellidos:** [Óscar Arriaza Gómez]
  - **Correo electrónico:** [oarrgoma1905@g.educaand.es]
  - **Iniciales del Alumno/Grupo:** [OAG]

## Descripción de la Actividad
[Deberemos responde a las siguientes preguntas relacionadas con el desarrollo software]

## Instrucciones de Compilación y Ejecución
1. **Requisitos Previos:**
   - [Lenguaje de programación y versión]
   - [Entorno de desarrollo o dependencias necesarias]

2. **Pasos para Compilar el Código:**
   ```bash
   [Comando para compilar el código]
   ```

3. **Pasos para Ejecutar el Código:**
   ```bash
   [Comando para ejecutar la aplicación]
   ```

4. **Ejecución de Pruebas:**
   ```bash
   [Comandos para ejecutar pruebas, si las hubiera]
   ```

## Desarrollo de la Actividad
### Descripción del Desarrollo
[Explicación de cómo se ha abordado el desarrollo de la actividad, incluyendo las decisiones de diseño, estructura del código y enfoque de resolución de problemas. Se recomienda adjuntar diagramas o capturas de pantalla si es necesario.]

### Código Fuente
[Aquí se incluirá un enlace directo a los archivos de código fuente en el repositorio, por ejemplo, si se está usando GitHub: `src/main.java` o algún enlace directo.]

### Ejemplos de Ejecución
- **Entrada 1:** Descripción de la entrada y valor de prueba.
- **Salida Esperada 1:** Explicación de la salida esperada y el resultado de la prueba.

### Resultados de Pruebas
[Aquí se detallará cómo se ha verificado la funcionalidad del código, incluyendo resultados de pruebas automatizadas o manuales, en caso de que las haya.]

## Documentación Adicional
- **Manual de Usuario:** [Enlace a la documentación del usuario, si existe]
- **Autorización de Permisos:** Verificar que el profesor tenga permisos de lectura en el repositorio para revisar el código.

## Conclusiones
[Resumen de las conclusiones alcanzadas al desarrollar la actividad, las lecciones aprendidas, y posibles mejoras que se puedan implementar en futuras entregas.]

## Referencias y Fuentes
[https://www.computerweekly.com/es/cronica/Los-desarrolladores-prefieren-los-lenguajes-JVM-para-dispositivos-moviles-y-empresas#:~:text=La%20JVM%20admite%20una%20gran,%2C%20Pizza%2C%20Pnuts%20y%20Xtend. 
https://apuntes.de/python/programacion-funcional-en-python-enfoque-modular-y-reutilizable/#gsc.tab=0 - 
https://immune.institute/blog/programacion-orientada-a-objetos/#:~:text=El%20paradigma%20orientado%20a%20objetos,sistemas%20de%20manera%20m%C3%A1s%20intuitiva. - https://www.ionos.mx/digitalguide/paginas-web/desarrollo-web/compilador-e-interprete/#:~:text=%C2%BFQu%C3%A9%20es%20un%20compilador%3F,c%C3%B3digo%20m%C3%A1quina%20antes%20de%20comenzar.]

### Notas Adicionales:
1. **Nombres de Archivos y Repositorios:**
   - Asegúrate de que el nombre del archivo o repositorio siga la estructura definida: `XXX-idActividad-Iniciales`.
2. **Permisos:**
   - Verifica que el profesor tenga los permisos necesarios para acceder al repositorio o documento.
3. **Formato:**
   - Si se entrega en formato PDF o Google Docs, asegúrate de cumplir con el mínimo y máximo de folios establecidos.
4. **Compilación y Ejecución:**
   - Detalla claramente cómo compilar y ejecutar el código, incluyendo las instrucciones en el archivo `README.md`.





# P1.10: Reflexión y Discursión sobre los resultados

# Indice

## 1.Relación software y hardawre
   
   ### Primera Parte
   ### Segunda Parte

## 2. Del código fuente al Ejecutable

## 3. Generación del Código

## 4. Lenguaje de Programación
   ### Primera Parte
   ### Segunda Parte
   ### Tercera Parte
   ### Reflexión Final

## 5. Herramientas de Desarrollo 
   ## Primera Parte 
   ## Segunda Parte
   ## Reflexión Final



# 1. Relación Software y Hardware
   ### Primera Parte
   1.1.1 ¿Cómo se ejecuta el código en el procesador?
   Realizando los calculos necesarios para que el código se pueda ejecutar
   
   1.1.2 ¿Qué hace la Memoria Ram con la información del Boton o del Led?
   Ejecutar la información que le proporciona al pulsar el boton o el LED
   
   1.1.3 ¿Cómo se comunica los periféricos (Botón y Led) con el procesador?
   Atraves de Buses de Datos

   ### Segunda Parte

   1.2.1 ¿Cómo interactúan el procesador, la memoria y los periféricos en la ejecución del programa? 
   Los periféricos le proporciona información al procesador para ejecute esa información y la memoria guarda dicha información.
  
   1.2.2 ¿Qué pasa con los datos en la memoria cuando el programa se ejecuta?
   Pues que se almacena todo en la memoria 
  
   1.2.3 ¿Qué roles juegan las instrucciones del software en esta interacción?
   Pues el software es el que da las indicaciones para que se realiza la tarea de una manera especifica
   
   1.2.4 ¿Cómo se relaciona esta simulación con lo que ocurre en un ordenador real

   # 2. Del código fuente al ejecutable
   2.1 ¿Cómo se diferencia el código fuente del código objeto y del ejecutable?
   Código fuente:  es el conjunto de instrucciones que el programador escribe utilizando un lenguaje de programación
   Código objeto: es el traductor de esas instrucciones 
   Código ejecutable: es la instrucción traducida
   
   2.2 ¿Por qué el ordenador no puede entender el código fuente directamente?
   Porque los ordenadores solamente comprenden la serie de unos y ceros que seria el lenguaje de maquina
   
   2.3 ¿Por qué es importante el paso de enlazado en la creación de programas?
   Porque es la que contiene las bibliotecas neceserias para que el programa se ejecute y es la que une todos los archivos de código objeto en uno para que se puedan ejecutar
   
   2.4 ¿ Qué ocurre si falta alguna de las etapas (código objeto o ejecutable)?
   Si falta el código objeto nadie traduce todas las intrucciones del código fuente y a su vez no se podria ejecutar

   # 3.Generación de Código intermedio
   3.1 ¿ ómo difiere el código intermedio del código ejecutable tradicional?
   Que el código intermedio puede ser ejecutado por muchas maquinas y el ejecutable en una sola.
  
   3.2 ¿Por qué es útil tener una máquina virtual?
   Porque es el encargado de ejecutar el código intermedio, traduciendo el código a instrucciones que el procesado pueda entender, un interprete
   
   3.3 ¿Qué ventajas ofrece el código intermedio? Ofrece portabilidad, Seguridad y optimización en tiempo de uso
   
   3.4 ¿Además de java, qué otros lenguajes usan máquinas virtuales? Kotlin, C#, Groovy, Scala, jRuby.  
   # 4.Lenguaje de Programación

   ## Primera parte
   4.1.1 ¿ Qué diferencias notaron en el proceso de compilación frente a la ejecución directa?
   El proceso de copilación te  lo ejecuta todo de golpe y en la ejecución directa la ejecuta línea por línea
   
   4.1.2 ¿Qué pasa si hay un error de sintaxis en cada lenguaje? ¿Cuándo se detecta el error?
  Pues que el código que has introducido esta mal y el propio programa te suele indicar donde esta el error, El error se detecta al ejecutar el código.
  ## Segunda Parte
  
  4.2.1 ¿Qué notaron sobre la abstracción entre los lenguajes de alto nivel y bajo nivel?
Pues que los de alto nivel son mas faciles de entender por los humanos y los de bajo nivel estan mas cerca del lenguaje de maquina

 4.2.2 ¿Qué ventajas y desventajas encontraron en cada uno?
  Alto Nivel: Ventajas: Los códigos son mas sencillos y entendible, puedes escribir programas mas dificiles en menos lineas, el código puede ser utiliza en diferentes sistemas
            Desventajas:Su rendimiento tiene una nlimitación y son mas lentos
  Bajo Nivel: Ventajas: Que es muy rapido, es adaptable y los códigos son faciles
            Desventajas: Al escribir el código es mas probable que te equivoques al ser mas tipo maquina.
  ## Tercera parte
  4.3.1 ¿Cómo funciona la organización de datos en Java usando objetos y métodos?
  Defininiendo las variables orientada a todos los objetos de un cierto tipo.

  4.3.2 ¿Cómo es diferente trabajar en un enfoque funcional en paython, usando funciones puras?
  Pues que son mas faciles de entender y depurar, porque nunca cambian el estado de un programa y siempre es el mismo resultado.
 

  # 4.4 Reflexión Final
  4.4.1 ¿Qué lenguajes se sintieron mas faciles de utilizar? ¿Por qué?
  Lenguaje de alto nivel, porque son mas sencillo de escribir y entendible por los humanos y son muchos mas funcionales.

  4.4.2 ¿En que casos es preferible usar un lenguaje compilado frente a uno interpretetado?
  Cuando quieras ser mas eficiente, porque el lenguaje copilado esta traducido y la velocidad es mayor al ejecutar toda la instrucción completa en vez de línea por línea
  
  4.4.3 ¿ Cuándo es mejor usar lenguaje de alto nivel en lugar de uno de bajo nivel?
  Cuando quieres que un humano lo entienda y sea mas sencillo de escribir y abstracto para el.
  
  4.4.4 ¿Como se siente trabajar con el paradigma orientado a objetos en comparación con el imperativo o funcional?
  Se siente mas intuitivo, una organización mas lógica y comprensiva del software   

  # 5. Herramientas de Desarrollo
  ### Primera Parte

  5.1.1 ¿Qué hace cada una de las herramientas?
  Software: donde se almacena el conjunto de instrucciones y datos en formato binario
  Editor de Texto: Escribe y modifica el código fuente de los programas
  Compiladores: Traducir el código fuente escrito en lenguajes como C o C++ a código máquina
  Herramientas de documentacíon: Mantiene la claridad del código y facilitar su comprensión
  Depuradores: Detienen la ejecución de un programa en puntos específicos y examinar su estado interno
  Sistemas de Gestión de Versiones: Rastrean los cambios en el código, trabajar en diferentes ramas de desarrollo y colaborar sin riesgo de sobrescribir el trabajo de otros

  5.1.2 ¿Qué tipo de tareas facilitas?
  Software: Almacenar Instrucciones y datos en formato binario
  Editor de texto: Escribir y modificar el código fuente
  Compiladores: Traducir el Código fuente
  Herramientas de documentación: Mantener claro el código y facilitar su comprensión
  Depuradores: Detener la ejecución
  Sistemas de Gestión de Versiones: Rastrear, trabajar y colaborar.

  5.1.3  ¿Qué características ofrece que la hacen única o diferente de otras herramientas similares?
  Software: Seguridad, Compatibilidad, transferibilidad, usabilidad,segurida etc
  Editor de Texto: Ligereza y Flexibilidad
  Compiladores:Generan código ejecutable de alto rendimiento y ofrecen más control sobre la optimización del código
  Herramienta de documentación: Aseguran tener todo actualizado con el código y Reducen el esfuerzo manual 
  Depuradores: Encontrar mas facil los errores complejos y ver el estado del código en tiempo real
  Sistemas de Gestión de Versiones: Permitir trabajar en equipo de manera eficiciente y segura

  5.1.4 Elige una ¿Cómo es la experiencia de usuario al usarla? ¿Es fácil o compleja?
  Editor de Texto: Pues tienes conocer muchos comandos para que sea mas ligero y fluido y ser mas sencillo, si conoces mucho los comandos es facil, si no se te puede hacer complejo

  5.1.5 Elige una ¿En qué situaciones sería ideal utilziar esta herramienta?
  Compiladores: Para crear programas que sean mas eficientes y rapidos y traducir el código fuente  de un proyecto de software a código maquina antes de ejecutarlo 
  
  5.1.6 Elige una ¿Qué limitaciones encontraste en la herramienta?
  El problema de formato, Compatibilidad entre plataformas, como no los guardes puedes perder los datos, complejidad de comandos y de las diferentes herramientas

  # Segunda parte

  5.2.1. ¿Qué herramienta se considera más útil y por qué?
  A mi me parece que un editor de texto es mas útil que una herramienta de documentación porque consume pocos recursos y al momento de la edición son rapidos

  5.2.2 ¿Qúe ventaja tiene una sobre otra?
  pues que es mucho mas flexible, consume poco, permite comparar archivos con es el caso de notepad++ y pluggins para añadir soporte a mas lenguaje

  5.2.3 ¿ Cuál herramienta resultó ser la más intuitiva y por qué?
  para mi los interpretes porque al escribir el código y darle a reproducir ese código te lo interpreta línea por línea instantaneo 

  5.2.4 ¿En qué casos se recomendaría usar un compilador en lugar de un intérprete?
  En el caso que quiera un código objeto mas optimo y que se pueda ejecutar de manera eficiente que gracias a ello la ejecución es mas veloz

  5.2.5 ¿Qué tipo de proyectos se beneficiarían más de un framework como Django?
  En la creación de aplicaciones web, en la creación de base de datos, formularios, administrar un lugar

  # Reflexión Final
  5.3.1 ¿Cómo crees que impacta la elección de la herramienta en la calidad del software?
Pues dependiendo impactara mas fuerte o no hay herramientas que no necesitas mucho esfuerzo del software y despues hay otra que son mas pesadas
  
  5.3.2 ¿Qué características buscarías en una herramienta para facilitar tu flujo de trabajo?
  Que sean optimas, rapidas, que sean flexibles, que contenga control sobre la ejecución de los códigos, facilitación de la edición del código

  5.3.3 ¿Cómo cambió tu percepción de estas herramientas después de haberlas probado y evaluado?
  Pues sabiendo que nunca habia utilizado ninguna herramienta excluyendo notepad++, cambio para bien porque es solo adaptarse y estar concentrado en lo que haces para que todo vaya fluido y sin problemas.

  
